//3.14;
//3.14f32;
//1e6;
//1.0e-5;
//1.4E2f32;
//
//111111u8;
//0xFF;
//0o777;
//0b1010;
//
//
//"escape\nsequence\tand quotes\"ok\"";
//
//r"no escapes here; \n stays \n";
//r#"contains "quotes" safely"#;
//r##"even # symbols are fine"##;
//
//b"abc";
//b"with\x20spaces";
//
//br"raw bytes";
//br#"with "quotes" inside"#;
//
//c"hello from C";
//cr#"raw C string"# ;
//cr##"raw C string with # inside"##;
//
//"Hello, World!";
//r"raw string";
//r#"raw with "quotes""#;
//r##"multi#hash raw"##;
//b"Hello\x20World";
//br"raw bytes";
//br##"raw bytes with # inside"##;
//c"Hello, C-string!";
//cr#"raw C-string"#;
//cr###"multi-hash raw C-string"###;
//
//b'A';
//b'a';
//
//name;
//welcome;
//identifier;
//
//true;
//false;
//
//foo.bar;
//person.name;
//config.value;
//
//tuple.0;
//point.1;
//pair.2;
//
//arr[0];
//arr[i * 1];
//matrix[1][2];
//foo[bar.baz];
//
//foo(1);
//foo(1, 2, 3);
//bar("hi", true);
//nested(outer(1), 2);
//
//add(1 * 2);
//
//foo.bar();
//foo.bar(1, 2);
//obj.method("hi", true);
//obj.method().other();
//self.compute().finish();
//
//future.await;
//foo.bar().await;
//read_file().await;
//x[0].await;
//
//foo()?;
//read_line()?.trim();
//get_value()?.to_string()?;
//arr[0]?;
//
//foo.bar().baz[0].qux().await?;
//tuple.0.call_method(42)[i].await;
//get_data()[index].field.call()?.another_call(1);
//user.info().friends[0].send_message("hi")?;
//
//-x;
//!flag;
//*ptr;
//&x;
//&mut y;
//&&ptr;
//&&mut ref_to_value;
//
//--x      ;     // double negation
//!!enabled;     // double logical not
//*&x      ;     // deref a reference
//*&mut y  ;     // deref a mutable reference
//&&*&mut z;     // layered: ref->ref->deref->mut
//-&*ptr   ;     // negation applied to deref’d pointer
//!*ptr    ;     // not of deref’d boolean
//&&mut *&x;     // ref→mut→deref→ref→ident
//
//-&foo.bar;     // negation + ref + field access
//!*data[0];     // logical not + deref + index
//&mut arr[1].value;
//&&mut *obj.method();
//-*&mut config.option()?.await;
//
//--value.call()?;
//!array[0].field.await;
//*&mut obj.method(1, 2);
//&&mut *&nested.field[2].call()?.await;
//
//
//a * b;
//x / y;
//n % 2;
//a * b / c % d;
//x * y / (z % w);
//
//1 * 2;
//(a / b);
//(1 / 2) * 3;
//x * (y / z);
//(x * (y / (z * w)));
//(*ptr).method();
//(&mut (arr[i / 1])).await;
//
//a as f32 * b;
//x / (y as i64);
//z % (w as u8);
//
//(1 as f32) * (2 as f64);
//a * (b as i32) / (c % d as u16);
//(x as f32 * y as f64) / (z as f64);
//
//a * b as f32  ;      // cast applies to b
//(a * b) as f32;      // cast applies to result
//1 / 2 as f64  ;      // should parse as 1 / (2 as f64)
//(1 / 2) as f64;      // should cast entire division
//
//1 + 2;
//a - b;
//
//x + y - z;
//1 + 2 * 3;
//4 - 5 / 6;
//7 % 8 + 9;
//a * b + c / d;
//x + y * z - w;
//
//(1 + 2) * 3;
//4 * (5 - 6);
//(7 + 8) / (9 - 10);
//a + b as f32;
//(a + b) as f32;
//
//x as f32 - y;
//(x - y) as f64;
//(1 + 2 as f32) * 3;
//1 + (2 as f32 * 3);
//1 + 2 * 3 - 4 / 5 % 6;
//
//(a as f32 + b * c as f64) / (d - e as i32);
//x - y + z * (w as f32 / 2);
//(1 + 2) as f32 + 3;
//((a - b) * (c + d as i32)) as f64;
//a + (b as f32 + (c * (d as f64)));
//
//a << b;
//x >> y;
//val << 2;
//num >> 3;
//
//a << b << c;
//x >> y >> z;
//a << b >> c;
//a + b << c;
//
//x >> y - z;
//1 + 2 << 3 - 4;
//(a + b) << (c - d);
//
//a * b << c / d;
//x >> y * z;
//(1 * 2) << (3 / 4);
//
//a << b as u32;
//(x as u64) >> y;
//(a << b) as u8;
//x >> (y as usize);
//
//(1 as i32) << (2 as i8);
//((a + b) << (c - d)) >> (e * f);
//(((x as i32) << 1) + (y as i32)) >> 2;
//
//*&x << *&y;
//-&a >> &mut b;
//!flag << 1;
//
//((a * b + c as i32) << (d - e)) >> (f / g as u8);
//((x as i64) >> (y + z * w)) + (q << (r as i32));
//
//a & b;
//x ^ y;
//p | q;
//
//a & b & c;
//x ^ y ^ z;
//a | b | c;
//
//a & b ^ c | d;
//x | y & z ^ w;
//a ^ b | c & d;
//
//a & b ^ c | d  //→  ((a & b) ^ c) | d;
//a << b & c >> d;
//x ^ y << z;
//a | b >> c;
//
//a + b & c - d;
//x * y ^ z / w;
//p | q + r;
//(1 + 2) & (3 ^ 4 | 5);
//
//a & (b as u32);
//(x ^ y) as i64;
//a | b as u8;
//
//(a + b & c ^ (d | e << f)) >> g;
//(x ^ (y & (z | (w << 1)))) + q;
//((a | b) & (c ^ d)) << (e | f);
//
//a == b;
//x != y;
//p < q;
//r <= s;
//t > u;
//v >= w;
//
//a == b == c;
//x != y != z;
//a < b <= c;
//p > q >= r;
//
//1 + 2 == 3;
//a * b != c / d;
//x - y < z + w;
//p + q <= r - s;
//m * n > o / p;
//
//a as f32 == b as f64;
//(x + y as i32) < (z as i64);
//(1 as f32) >= (2 as f64);
//a + b as u32 != c;
//
//a << 1 == b >> 2;
//(x >> y) != (z << w);
//(a << b) <= (c >> d);
//
//a & b == c | d;
//x ^ y != z & w;
//(a | b) < (c ^ d);
//a & b <= c & d;
//
//(a + b * c) == (d << e | f);
//(x & y ^ z) != (a + b * c);
//((a << 2) | (b & 3)) >= (x ^ y);
//(1 + 2) * 3 < (4 >> 1);
//
//(a + b as i32) < (c & d) >> 1;
//(x | y) == (z ^ w) + (q << 2);
//(1 + 2 * 3) != ((4 << 1) | 5);
//(a + b * c) <= (d - e as f64);
//
//true && false;
//true || false;
//a && b;
//x || y;
//
//a && b && c;
//x || y || z;
//a && b || c;
//a || b && c;
//
//a < b && b < c;
//x == y || y != z;
//p >= q && r <= s;
//m > n || n < o;
//
//(1 + 2) < 3 && (4 * 5) > 6;
//a + b == c && d - e != f;
//x / y > z || a * b < c;
//
//(a & b) == c && (x | y) != z;
//p << q > r || s >> t < u;
//(a ^ b) != (c & d) || (x >> y) == z;
//
//(a as i32) < (b as i64) && (x as f32) > (y as f64);
//a + b as f32 == c && (d as i64) != e;
//
//(a && (b || c)) && d;
//(a || (b && c)) || d;
//((a < b) && (b < c)) || (d == e);
//
//(a + b * c < d) && ((x >> y) == z || w <= u);
//(a & b | c ^ d) != e && (x + y) > (z as f32);
//(1 + 2 == 3) || (4 * 5 < 6 && 7 > 8);;
//
//1..5;
//1..=5;
//a..b;
//a..=b;
//x..;      // from only
//..y;      // to only
//..=z;     // to inclusive
//..;       // full range
//
//(a + b)..(c + d);
//(a * 2)..=b;
//x..(y || z);
//(x && y)..z;
//1..(2 && 3);
//(1 || 2)..3;
//
//
//a..b || c..d;
//a..=b && c..=d;
//(a..b) || (c..d);
//(a..=b) && (c..=d);
//(a..b) || c;
//a || (b..c);
//(a && b)..(c || d);
//
//x + 1..y - 1;
//(1 + 2)..=(3 * 4);
//(a < b)..(c > d);
//(a == b)..=(c != d);
//
//(1..);
//(..2);
//(..=3);
//(..);
//a..=b..c;     // chained — should stop at first range op
//x..(y..z);    // nested ranges in parens
//foo(1..10);
//arr[1..=len];
//
//(a && b)..(c || d);
//a..b && c..d;
//(a || b)..c;
//a && b..c;
//(1 < 2)..(3 > 4) || (x && y);
//
//a = b;
//x = 1;
//flag = true;
//message = "hello";
//
//a += b;
//x -= y;
//value *= 10;
//count /= 2;
//modd %= 3;
//
//mask &= flag;
//mask |= 0xFF;
//bits ^= other_bits;
//shift <<= 2;
//shift >>= 1;
//
//x = a + b * c;
//y += (m - n) / 2;
//z *= (a + b) as f32;
//total /= x << 1;
//flag |= (a & b) ^ (c | d);
//
//r1 = 1..5;
//r2 = a..=b;
//r3 = ..10;
//r4 = (x + 1)..(y - 1);
//
//data = arr[1..=len];
//slice = items[..];
//
//a = b = c;
//x = y += z;
//counter = total = value * 2;
//
//result = (a + b) * (c - d);
//matrix[i][j] = a * b + c / d;
//obj.value += (a..b).len();
//foo.bar -= x >> 2;
//bar.baz <<= (a + b) & (c - d);
//
//x = a < b;
//y = x == y;
//cond = (a && b) || (c && d);
//flag = (a..b) == (c..d);
//
//(a += b);
//(x -= y * z);
//foo.bar().baz[1] <<= (x..y);
//result >>= (input & mask);
//((a..b) += (c..d)); // syntactically valid for parser test
//
//[1];
//[1, 2, 3];
//[a, b, c];
//[true, false, flag];
//["hello", "world", "duck"];
//
//[1, 2, 3,];
//[a, b, c,];
//[x + y, y - z, z * 2,];
//
//[[1, 2], [3, 4]];
//[[a, b], [c, d], [e, f]];
//
//[1..5, a..=b];
//[..10, (x + 1)..(y - 1)];
//[(a..b), (c..=d)];
//
//[(a + b) * c, x << y, y >> z];
//[(a & b) | c, a ^ b, (x > y) && (z < w)];
//
//[0; 5];              // 5 zeros
//["hi"; 10];          // 10 "hi" strings
//[flag; 2];           // repeat boolean flag twice
//[(a + b); count];    // repeat expression
//
//[[1, 2]; 3];         // repeat [1, 2] three times
//[[a, b, c]; n];      // repeat [a, b, c] n times
//
//[ [1, 2], [3; 2], [a + b, c * d] ];
//[ (1 + 2), (3 * 4), [5, 6, 7], (8..10) ];
//
//[foo(), bar(1, 2), baz.value];
//[obj.method(); count];
//[user.info().friends; total];
//
//[ ];             // empty array
//[ x ];           // single expression
//[ (x + y), ];    // trailing comma with grouped expr
//[ [ [ ] ] ];     // nested empty arrays
//[ arr[i]; len ]; // repetition with indexed expr
//

//(1, 2);
//("hello", "world");
//(true, false);
//(a, b);
//(x, y, z);
//
//(1,);
//("hi",);
//(a,);
//((x + y),);
//
//(); // should NOT be tuple, it will be unit
//
//(1 + 2, );
//(1 + 2, a * b);
//(x / y, (a + b) * c);
//(foo(), bar(1, 2));
//((a..b), [1, 2, 3]);
//
//((1, 2), 3);
//(1, (2, 3));
//((a, b), (c, d));

//(#inline, 1, 2); 
//(#debug, (a + b), c);

//( (1, 2), [a, b, c], (true, false), ("x", "y", "z") );
//((1, (2, (3, 4))), (a + b, c * d));
//( [1, 2], (x..y), func_call(1, 2) );
//
//(1, 2, 3,);
//(a, b, c,);
//(foo(), bar(), baz(),);
//
//(1);    // group
//(1,);   // tuple
//(a);    // group
//(a,);   // tuple
//(foo()); // group
//(foo(),); // tuple
//
//(x + y);
//(heavy_computation());
//(#![inner] (x * y));
//();
//(#![inner] (x + y), z, w);
//(#![debug::foo::bar]);
//(#![::debug::foo]);
//(#![$crate::debug]);
//(#![name = "foo"]);
//(#![cfg(feature = "debug")] 1 + 2);
//(1, 2);
//(#[inline] 1, 2);
//(#[inline] #[cfg(feature = "debug")] 1, 2);
//(#[allow(dead_code)]);
//(#[debug = "true"] 42);
//(#![allow(unused_variables)] 10);
//(#![cfg(feature = "debug")] #[inline] 123, 456);
//(#[test] (#![cfg(feature = "inner")] 1, 2), 3);
//(#[cfg(debug_assertions)] (1 + 2), (3 * 4));
//(#[cfg(feature = "x")] (#![inner_attr] (5)));
//(1 + 2);
//(#![feature(special_attr)] (2 * 3));
//((#![allow(unused)] (1)));
//(#![cfg(feature = "debug")] #[inline(always)] (x + y * 2));
//(#![feature(tuple_attrs)] (#[inline] (1, 2)));
//(#![cfg_attr(feature = "debug", allow(dead_code))] (a + b));
//
//// --- Basic named struct ---
//struct User {
//  id: i32,
//  name: String,
//}
//
//// --- Tuple struct ---
//struct Point(f64, f64);
//
//// --- Unit struct ---
//struct Empty;
//
//// --- public named struct ---
//pub struct Config {
//    key: String,
//    value: String,
//}
//
//// --- Scoped visibility ---
//pub struct InternalData;
//pub(super) struct ChildOnly;
//pub(self) struct SelfVisible;
//pub(in crate::core::system) struct ScopedPath;
//
//// --- Struct with generics ---
//struct Wrapper<T> {
//  item: T,
//}
//
//// --- Struct with multiple generic parameters ---
//struct Pair<K, V> {
//    key: K,
//    value: V,
//}
//
//// --- Struct with generic bounds ---
//struct Limited<T: Clone + Default> {
//    data: T,
//}
//
//// --- Struct with lifetime parameter ---
//struct Ref<'a> {
//    value: &'a str,
//}
//
//
//// --- Struct with lifetime and generic ---
//struct Scoped<'a, T> {
//    data: &'a T,
//}
//
//// --- Struct with const generic ---
//struct Buffer<const N: usize> {
//    bytes: [u8; N],
//}
//
//// --- Struct with lifetime + const generic ---
//struct Bounded<'a, const N: usize> {
//    buf: &'a [u8; N],
//    buf2: &[u8; N],
//}
//
//
//// --- Struct with generic defaults ---
//struct Defaulted<T = String> {
//    inner: T,
//}
//
//// --- Struct with generic bounds and defaults ---
//struct SmartBox<T: Clone + Default = StringType<String>> {
//    value: T,
//}
//
//// --- Struct with where clause ---
//struct Complex<T, U>
//where
//    T: Clone + PartialEq,
//    U: Default,
//{
//    left: T,
//    right: U,
//}
//
//// --- Struct with lifetime bounds ---
//struct ScopedRef<'a: 'b, 'b> {
//    r: &'b &'a str,
//}
//
//// --- Tuple struct with visibility and generics ---
//pub struct Vec2<T>(pub T, pub T);
//
//// --- Unit struct with attribute ---
//#[derive(Debug, Clone)]
//struct Marker;
//
//// --- Named struct with field attributes ---
//struct Annotated {
//    #[allow(dead_code)]
//    #[cfg(feature = "debug")]
//    debug_name: String,
//
//    #[deprecated(note = "use `active` instead")]
//    enabled: bool,
//}
//
//// --- Struct with path-based type ---
//struct Nested {
//    inner: crate::module::DeepType,
//}
//
//// --- Struct with complex where clause ---
//pub struct Graph<K, V>
//where
//    K: Eq + std::hash::Hash,
//    V: Clone + Default,
//{
//    nodes: Vec<(K, V)>,
//}
//
//// --- Empty tuple struct with visibility ---
//pub struct Token();
//
//// --- Struct with Self type references ---
//struct SelfAware {
//    next: Option<Self>,
//}
//
//// --- Nested generic parameters ---
//struct Container<T: IntoIterator<Item = U>, U> {
//    values: T,
//    marker: std::marker::PhantomData<U>,
//}
//
//// --- Struct using const generics with expressions ---
//struct Matrix<const ROWS: usize, const COLS: usize> {
//    data: [[f32; COLS]; ROWS],
//}
//struct Container<U: IntoIterator<Item>>
//where
//    T: IntoIterator<'a, Item>,
//{
//    values: T,
//    marker: std::marker::PhantomData<U>,
//}
