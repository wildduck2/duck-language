b"\"" 
//b"\"";
//br#"\""#;
//"hello";
//"escaped \" quote";

//// minimal valid static without initializer
//static A: i32;
//
//// static with initializer
//static B: i32 = 42;
//
//// mutable static without initializer
//static mut C: i32;
//
//// mutable static with initializer
//static mut D: i32 = 0;
//
//// complex type without initializer
//static E: Option<i32>;
//
//// complex type with initializer
//static F: Option<i32> = None;
//
//// reference type without initializer
//static G: &'static i32;
//
//// reference type with initializer
//static H: &'static i32 = &10;
//
//// array type without initializer
//static I: [i32; 3];
//
//// array type with initializer
//static J: [i32; 3] = [1, 2, 3];
//
//// generic path type
//static K: Result<i32, i32>;
//
//// generic path type with initializer
//static L: Result<i32, i32> = Ok(5);
//
//// nested generic type
//static M: Option<Result<i32, i32>>;
//
//// nested generic with initializer
//static N: Option<Result<i32, i32>> = Some(Ok(1));
//
//// function pointer type
//static O: fn(i32) -> i32;
//
//// function pointer with initializer
//static P: fn(i32) -> i32 = foo;
//
//// tuple type
//static Q: (i32, i32);
//
//// tuple with initializer
//static R: (i32, i32) = (1, 2);
//
//// unit type
//static S: ();
//
//// unit with initializer
//static T: () = ();
//
//// mutable complex type
//static mut U: Vec<i32>;
//
//// mutable complex with initializer
//static mut V: Vec<i32> = Vec::new();
//
//// deeply nested path
//static W: crate::module::Type;
//
//// deeply nested path with initializer
//static X: crate::module::Type = crate::module::Type::new();
//
//// underscore identifier edge case
//static _: i32;
//
//// long identifier
//static VERY_LONG_STATIC_IDENTIFIER_NAME_123: i64 = 99;
//
//static _: i32;
//static _: i32 = 0;
//static mut _: i32;
//static mut _: i32 = 0;
//
