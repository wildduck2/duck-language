@duck-rust-full-compiler
============

Change Log
----------
2025-12-11
- Expanded `core/lox/duck.lox` with every operator combo we currently support so regression runs
  stress every precedence layer before future semantic work kicks in.
- Tightened the lexer/parser handshake: shift tokens now stay split for `<<`, `parse_path` stops
  before field access, and logical/comparison layers rely on the same `can_start_expression`
  helpers, eliminating spurious RHS diagnostics.
- Refactored postfix/cast/unary parsing so casts can chain into calls/fields/indexing, `.await?`
  survives after type ascriptions, and multi-depth borrows like `&& &mut *&mut -!value` become
  valid `Expr::Unary` nodes.
- Brought range, pattern, and match parsing up to date (range patterns, guard-aware notes, TODO
  refresh) and cleaned the grammar notes to reflect the broader Rust subset we now accept.

2025-12-07
- Added MIT `LICENSE` files for every crate/workspace (including the TypeScript shim) to document
  redistribution terms explicitly.
- Removed the unused `index.ts` TypeScript entrypoint, tightened `rustfmt.toml`, and tweaked
  parser/rustfmt settings so formatting and helper utilities stay consistent across the repo.

2025-11-28
- Statement parsing now collects outer attributes/visibility for every stmt or expr and threads a
  strict `ExprContext` through expression + pattern parsing, so control-flow keywords trigger the
  right diagnostics and match arms inherit the correct scope metadata.
- Closures finally look like Rust: async/move flavors, attribute-decorated parameter lists, optional
  return types, and proper body expressions all emit `Expr::Closure` nodes wired into the AST.
- Block parsing picked up async/move/unsafe/try flavor validation, block labels, and FatArrow-driven
  match arm handling, letting attribute-decorated arms fall through to block vs expr bodies safely.
- Diagnostics/lexer polish: deduplicated formatting output, added targeted errors for invalid block
  flavors or conditions, and extended the lexer/token kinds with the `=>` arm plus consistent comma
  handling to keep match parsing stable.

2025-11-27
- Dropped in the block/control-flow machinery: block expressions now capture labels, outer/inner
  attributes, and async/move/unsafe/try flavors, while `if`/`break`/`continue`/`return` create their
  own AST nodes for future semantic work.
- Built the macro-invocation pipeline with token-tree capture, delimiter tracking, and repeat kinds,
  enabling `path! { ... }` invocations to appear in expressions and patterns even before expansion.
- Reworked the expression dispatcher so statements parse attributes + visibility before deciding
  between items, lets, or expression statements, giving the parser enough structure to grow.

2025-11-26
- Introduced a full match-expression parser with attribute-aware arms, optional `if` guards, and
  proper AST nodes for scrutinee + bodies, backed by fresh diagnostics and sample programs.
- Extended the pattern/type/path stack with slices, tuple structs, macro patterns, QSelf headers,
  and better mutability parsing so destructuring and generics keep pace with Rust's grammar.
- Tightened parser utilities plus lexer + diagnostic support around the new syntax, including
  bitwise/logical lexer fixes and richer error codes to keep recovery predictable.

2025-11-16
- Assembled the pattern-matching core: bindings, tuple/struct/slice/rest patterns, reference depth,
  macro patterns, and binding modes now live under `ast/pattern` with shared helpers.
- Plugged the new patterns into `let` statements/expressions (with optional types and initializers),
  priming declaration parsing even while the statement emitter remains WIP.
- Filled in missing literal/identifier expression layers and parser utilities so unary/postfix flows
  produce consistent trees for the rest of the grammar.
- Cleaned up lifetime lexing/handling so `'static`, `'_`, and named lifetimes survive generics,
  where clauses, and pattern annotations without mis-tokenizing.

2025-11-15
- Rebuilt the literal lexers end-to-end: byte/raw/C/string scanners now share prefix validation,
  escape checking, and unterminated span reporting identical to Rust's rules.
- Revamped numeric parsing to enforce decimal/fraction/exponent ordering, base-specific separators,
  and suffix detection, emitting targeted diagnostics when underscores or suffixes misbehave.

2025-11-14
- Finished the array expression parser plus AST printer plumbing (repeat `[v; n]`, trailing commas,
  empty arrays) so tree dumps mirror the Rust grammar when debugging.
- Overhauled struct and generic path parsing: `struct` declarations now accept record/tuple/unit
  forms with visibility, attributes, generics, and `where` clauses, and the path parser learned
  about `$crate`, `pub(in ..)`, and other visibility fixes.
- Documented the grammar cleanup (new TODO sections per parser module) and fixed the lingering
  import/path resolution issues exposed by the refactor.

2025-11-13
- Added lifetime, mutability, and `where` clause parsers (plus supporting diagnostics) and wired
  them into struct/type/generic parsing so trait/lifetime bounds read like real Rust.
- Extended visibility + path parsing to cover `pub`, `pub(crate)`, `pub(in module)`, and multi-segment
  forms, unblocking type + struct definitions with richer access modifiers.
- Hardened the lexer/parser hand-off for contextual keywords and shift operators, teaching the lexer
  to split `<<`/`>>` tokens properly and feeding a dedicated shift-expression parser.

2025-11-12
- Completed the generics/struct push by refactoring the AST (new `ast/mod.rs`, dedicated print
  modules, and split-out path definitions) so expanded tree output stays maintainable.
- Polished the Rust-like type pipeline—grouped-expression, generic, struct, and type parsers now
  share clearer helpers and emit better diagnostics across field shapes and nested arguments.
- Added dedicated attribute, path, and visibility parsers, hooked them into the entrypoint, and
  covered them with `core/lox/duck.lox` samples plus new diagnostic error kinds.
- Tightened lifetime and literal lexing (contextual keywords, escape handling, spans) and broadened
  regression tests to lock in the new edge-case coverage.

2025-11-11
- Unblocked tuple/group expression parsing with attribute propagation, AST printer updates, and
  real programs that mix inner/outer attributes inside nested tuples.
- Removed the duplicated AST monolith in favor of a modular `ast/mod.rs` + printer setup, giving
  `print_tree` richer output while keeping definitions in one place.
- Brought in the first full cut of Rust-style type + struct parsing (generic arguments, field
  initializers, path unification) and retired the old parser scaffolding.
- Hardened literal scanning by recognizing prefixed/raw string starters through a helper and by
  enforcing that shebangs only trigger in column zero.

2025-11-10
- Extended the expression parser through unary, factor, cast, shift, and bitwise layers, keeping 
  the AST updates and grouped-expression handling in sync.
- Fixed the lexer `match` helper so it no longer skips characters when matching punctuation-heavy 
  tokens.

2025-11-09
- Completed primary expression coverage by wiring identifiers, booleans, postfix operators, and 
  string/float literals between the lexer and parser.
- Refined literal scanning (float/integer unification, suffix guards, empty-line comment recovery)
  to harden the lexer’s edge cases.
- Polished developer feedback with severity color fixes plus refreshed BNF grammar notes and the 
  AST print tree output.

2025-11-08
- Added unified numeric literal suffix scanning (integers `u8`/`i32` etc. and floats `f32`/`f64`)
  across every base, plus diagnostics for malformed suffixes and reserved prefixes.
- Introduced lifetime lexing (`'a`, `'static`, `'_`) with invalid-number detection, integrating 
  it with the character literal fallback path.
- Completed the literal pipeline (raw/byte/C strings, escape validation, prefix filtering) and 
  tightened shebang parsing semantics.
- Expanded lexer regression tests (keywords/operators, literal coverage, numeric suffix failures,
  lifetimes) to guard the new behavior.

2025-11-07
- Implemented the full string and character literal system (regular, byte, raw, byte-raw, C, raw-C)
  including escape/unicode handling and diagnostics for unterminated/invalid tokens.
- Added raw-string recovery at EOL, escape validation diagnostics, and supporting helpers within 
  the literal module.
