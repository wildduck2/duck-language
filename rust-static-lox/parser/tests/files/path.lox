// Valid path expressions
foo;
foo::bar;
::foo::bar;
foo::bar::baz;
::foo::bar::baz;
self;
super;
crate;
$crate;
self::foo;
super::foo;
crate::foo;
$crate::foo;
::$crate;
self::super::crate;
::self::super::crate;
foo::bar::<T>;
foo::bar::<T, U>;
foo::bar::<T, U, V>;
::foo::bar::<T>;
::foo::bar::<T, U>;
foo::<T>;
foo::<T>::bar;
foo::<T>::bar::<U>;
foo::bar::<T>::baz;
foo::bar::<T>::baz::<U>;
Self::<T>;
Self::<T>::Assoc;
Self::<T>::Assoc::<U>;
crate::Type::<T>::Assoc::<U>;
self::Type;
super::Type;
crate::Type;
$crate::Type;
self::Type::<T>;
super::Type::<T>::Assoc;
Self::Assoc;
Self::Assoc::<T>;
<T>::Item;
<T>::Item::<U>;
<Self>::Assoc;
<$crate::Type>::Assoc;
<crate::Type as Trait>::Item;
<crate::Type as Trait>::Item::<U>;
<super::Type as Trait>::Item::Sub;
<Self as Trait>::Item::Assoc::Deep;
<crate::Type as Trait>::Item::Assoc::Deep::<U>;
<::foo as Trait>::Item;
<::foo::bar as Trait>::Item;
<::crate::Type as Trait>::Assoc;
<::super::Type as Trait>::Assoc::<T>;
::foo::<T>::bar::<U>::baz;
<T>::Item::Assoc::Deep::<U>;
<Self>::Assoc::Deep::Deeper;
<crate::Type as Trait>::Item::Assoc::Deep::Deeper::<U>;

// Invalid/Error cases - should produce parse errors
// These are commented out so they can be tested later
//foo::<>::bar;
//foo::<> <T as>::Item <T Trait>::Item;
//<>::Item <T>::;
//<T as>::Item;
//<T>::;
//foo::<T>::;
//::;
//foo:bar;
//foo:::bar;
//<T as Trait>::;
//< as Trait>::Item;
//<T as >::Item;
//foo::<T,>::bar;
//foo::<,T>::bar;
//foo::<T U>::bar;
//Self::<>;
//<Self as>::Assoc;
//<::>::Item;
//foo::bar::<T>::;
//<T>::Item::;
//<T>::Item::<U>::;
//<T>::Item::<U>::<V>;
//foo::<T>::<U>::bar;
//<T>::Item::Assoc::<U>::<V>;
//<T as Trait>::Item::<U>::<V>;
//<T as Trait>::Item::Assoc::<U>::<V>::<W>;
