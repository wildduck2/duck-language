Ideas to reduce diagnostic duplication:
- Centralize common “unexpected token” builders: add helpers on Parser (or a small DiagnosticFactory) that take expected tokens/contexts and build consistent labels/notes. Replace repeated ad-hoc messages in parse_* modules.
- Introduce small combinators for “parse list with separators” (ex: bounds, parameters, fields). Let the helper handle trailing separators, empty lists, and delimiter diagnostics so individual parsers only provide element parsers and expected delimiters.
- Normalize “trailing separator” checks: provide a utility that, after consuming a separator, inspects the next token and emits a standard trailing-separator diagnostic; reuse it in generics, bounds, tuple/struct initializers.
- Reuse shared messages for lifetime/trait bounds: one function to render “expected another trait or lifetime bound after `+`”, including examples, so lifetime and trait-bound code paths call the same routine.
- Capture context in diagnostics (e.g., “in where-clause” vs “in generic args”) by passing an enum context into the helpers to tailor wording while keeping structure identical.
- Reduce repetitive `matches!` chains:
  - Introduce small predicates like `is_bound_start(token.kind)` or `is_path_start_or_lifetime(token.kind)` that encapsulate the long token lists. Use them in loops and lookahead checks to avoid inline `matches!` noise.
  - Wrap multi-token stop-conditions in helpers: e.g., `is_bound_terminator(token.kind)` to replace repeated `matches!(..., TokenKind::Gt | TokenKind::Comma | ...)`.
  - For “consume plus then validate next” patterns, write a helper `consume_plus_and_require_bound(self, engine, context)` that handles `match_and_consume!(+, ...)` and the follow-up `matches!` guard in one place.
