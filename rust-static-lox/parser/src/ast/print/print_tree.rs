// THIS FILE IS FULLY GENERATED BY AI DO NOT EDIT
// ----------------------------------------------------------------------------
//  its made for debugging purposes only
// ----------------------------------------------------------------------------
// Print Tree Methods
// ----------------------------------------------------------------------------

impl Type {
  pub fn print_tree(&self, prefix: &str, is_last: bool) {
    let connector = if is_last { "└─>" } else { "├─>" };

    match self {
      // Primitive integer types
      Type::I8 => println!("{}{} i8", prefix, connector),
      Type::I16 => println!("{}{} i16", prefix, connector),
      Type::I32 => println!("{}{} i32", prefix, connector),
      Type::I64 => println!("{}{} i64", prefix, connector),
      Type::I128 => println!("{}{} i128", prefix, connector),
      Type::Isize => println!("{}{} isize", prefix, connector),
      Type::U8 => println!("{}{} u8", prefix, connector),
      Type::U16 => println!("{}{} u16", prefix, connector),
      Type::U32 => println!("{}{} u32", prefix, connector),
      Type::U64 => println!("{}{} u64", prefix, connector),
      Type::U128 => println!("{}{} u128", prefix, connector),
      Type::Usize => println!("{}{} usize", prefix, connector),

      // Floating point types
      Type::F32 => println!("{}{} f32", prefix, connector),
      Type::F64 => println!("{}{} f64", prefix, connector),

      // Other primitive types
      Type::Bool => println!("{}{} bool", prefix, connector),
      Type::Char => println!("{}{} char", prefix, connector),
      Type::Str => println!("{}{} str", prefix, connector),
      Type::Never => println!("{}{} !", prefix, connector),
      Type::Unit => println!("{}{} ()", prefix, connector),
      Type::SelfType => println!("{}{} Self", prefix, connector),

      // Path types
      Type::Path(path) => {
        println!("{}{} Path: {}", prefix, connector, format_path(path));
      },

      // Reference types
      Type::Reference {
        lifetime,
        mutability,
        inner,
      } => {
        let mut_str = if *mutability == Mutability::Mutable {
          "mut "
        } else {
          ""
        };
        let life_str = lifetime
          .as_ref()
          .map(|l| format!("'{} ", l))
          .unwrap_or_default();
        println!("{}{} &{}{}", prefix, connector, life_str, mut_str);
        let new_prefix = format!("{}{}  ", prefix, if is_last { " " } else { "│" });
        inner.print_tree(&new_prefix, true);
      },

      // Slice and Array
      Type::Slice(inner) => {
        println!("{}{} [_]", prefix, connector);
        let new_prefix = format!("{}{}  ", prefix, if is_last { " " } else { "│" });
        inner.print_tree(&new_prefix, true);
      },

      Type::Array { element, size } => {
        println!("{}{} Array [_; _]", prefix, connector);
        let new_prefix = format!("{}{}  ", prefix, if is_last { " " } else { "│" });
        println!("{}├─> Element:", new_prefix);
        element.print_tree(&format!("{}│  ", new_prefix), false);
        println!("{}└─> Size:", new_prefix);
        size.print_tree(&format!("{}   ", new_prefix), true);
      },

      // Tuple
      Type::Tuple(types) => {
        println!("{}{} Tuple", prefix, connector);
        let new_prefix = format!("{}{}  ", prefix, if is_last { " " } else { "│" });
        for (i, ty) in types.iter().enumerate() {
          ty.print_tree(&new_prefix, i == types.len() - 1);
        }
      },

      _ => {
        println!("{}{} [Other Type]", prefix, connector);
      },
    }
  }
}

impl Stmt {
  pub fn print_tree(&self, prefix: &str, is_last: bool) {
    let connector = if is_last { "└─>" } else { "├─>" };

    match self {
      Stmt::Expr(expr) => {
        println!(
          "{}{} parse_expr()  (for expression statements)",
          prefix, connector
        );
        let new_prefix = format!("{}{}  ", prefix, if is_last { " " } else { "│" });
        expr.print_tree(&new_prefix, true);
      },
      Stmt::Semi(expr) => {
        println!("{}{} Stmt::Semi", prefix, connector);
        let new_prefix = format!("{}{}  ", prefix, if is_last { " " } else { "│" });
        expr.print_tree(&new_prefix, true);
      },
      Stmt::TailExpr(expr) => {
        println!("{}{} Stmt::TailExpr", prefix, connector);
        let new_prefix = format!("{}{}  ", prefix, if is_last { " " } else { "│" });
        expr.print_tree(&new_prefix, true);
      },
      Stmt::Let {
        pattern, ty, init, ..
      } => {
        println!(
          "{}{} parse_let_statement()  (for let statements)",
          prefix, connector
        );
        let new_prefix = format!("{}{}  ", prefix, if is_last { " " } else { "│" });
        println!("{}├─> pattern: {:?}", new_prefix, pattern);
        if let Some(ty) = ty {
          println!("{}├─> type:", new_prefix);
          ty.print_tree(&format!("{}│  ", new_prefix), init.is_none());
        }
        if let Some(init) = init {
          println!("{}└─> init:", new_prefix);
          init.print_tree(&format!("{}   ", new_prefix), true);
        }
      },
      Stmt::Item(item) => {
        println!("{}{} Stmt::Item", prefix, connector);
        let new_prefix = format!("{}{}  ", prefix, if is_last { " " } else { "│" });
        item.print_tree(&new_prefix, true);
      },
      Stmt::Empty => {
        println!("{}{} Stmt::Empty", prefix, connector);
      },
      _ => {
        println!("{}{} [Other Stmt]", prefix, connector);
      },
    }
  }
}

use crate::ast::*;

impl Expr {
  pub(crate) fn span(&self) -> Span {
    match self {
      Expr::Integer { span, .. }
      | Expr::Float { span, .. }
      | Expr::String { span, .. }
      | Expr::Char { span, .. }
      | Expr::ByteString { span, .. }
      | Expr::Byte { span, .. }
      | Expr::Bool { span, .. }
      | Expr::Binary { span, .. }
      | Expr::Unary { span, .. }
      | Expr::Assign { span, .. }
      | Expr::AssignOp { span, .. }
      | Expr::Field { span, .. }
      | Expr::MethodCall { span, .. }
      | Expr::Call { span, .. }
      | Expr::Index { span, .. }
      | Expr::Range { span, .. }
      | Expr::Array { span, .. }
      | Expr::Tuple { span, .. }
      | Expr::Struct { span, .. }
      | Expr::If { span, .. }
      | Expr::IfLet { span, .. }
      | Expr::Match { span, .. }
      | Expr::Loop { span, .. }
      | Expr::While { span, .. }
      | Expr::WhileLet { span, .. }
      | Expr::For { span, .. }
      | Expr::Return { span, .. }
      | Expr::Break { span, .. }
      | Expr::Continue { span, .. }
      | Expr::Yield { span, .. }
      | Expr::Become { span, .. }
      | Expr::Closure { span, .. }
      | Expr::Block { span, .. }
      | Expr::Await { span, .. }
      | Expr::Try { span, .. }
      | Expr::Cast { span, .. }
      | Expr::Type { span, .. }
      | Expr::Let { span, .. }
      | Expr::Box { span, .. }
      | Expr::Underscore { span, .. }
      | Expr::Paren { span, .. }
      | Expr::InlineAsm { span, .. }
      | Expr::Ident { span, .. }
      | Expr::Group { span, .. }
      | Expr::Unit(span)
      | Expr::FormatString { span, .. } => *span,
      Expr::Path(_) => Span::default(),
      Expr::Macro { mac, .. } => mac.span,
      Expr::TupleStruct {
        path,
        elements,
        span,
      } => todo!(),
    }
  }

  pub fn print_tree(&self, prefix: &str, is_last: bool) {
    let connector = if is_last { "└─>" } else { "├─>" };

    match self {
      Expr::Integer { value, suffix, .. } => {
        println!(
          "{}{} Integer: {}{}",
          prefix,
          connector,
          value,
          suffix.as_ref().map(|s| s.as_str()).unwrap_or("")
        );
      },
      Expr::Float { value, suffix, .. } => {
        println!(
          "{}{} Float: {}{}",
          prefix,
          connector,
          value,
          suffix.as_ref().map(|s| s.as_str()).unwrap_or("")
        );
      },
      Expr::String { value, kind, .. } => {
        println!("{}{} String({:?}): \"{}\"", prefix, connector, kind, value);
      },
      Expr::Char { value, .. } => {
        println!("{}{} Char: '{}'", prefix, connector, value);
      },
      Expr::Byte { value, .. } => {
        println!("{}{} Byte: '{}'", prefix, connector, value);
      },
      Expr::Bool { value, .. } => {
        println!("{}{} Bool: {}", prefix, connector, value);
      },
      Expr::Binary {
        left, op, right, ..
      } => {
        println!("{}{} Binary {:?}", prefix, connector, op);
        let new_prefix = format!("{}{}  ", prefix, if is_last { " " } else { "│" });
        left.print_tree(&new_prefix, false);
        right.print_tree(&new_prefix, true);
      },
      Expr::Unary { op, expr, .. } => {
        println!("{}{} Unary {:?}", prefix, connector, op);
        let new_prefix = format!("{}{}  ", prefix, if is_last { " " } else { "│" });
        expr.print_tree(&new_prefix, true);
      },
      Expr::Assign { target, value, .. } => {
        println!("{}{} Assign", prefix, connector);
        let new_prefix = format!("{}{}  ", prefix, if is_last { " " } else { "│" });
        target.print_tree(&new_prefix, false);
        value.print_tree(&new_prefix, true);
      },
      Expr::Call { callee, args, .. } => {
        println!("{}{} Call", prefix, connector);
        let new_prefix = format!("{}{}  ", prefix, if is_last { " " } else { "│" });
        callee.print_tree(&new_prefix, args.is_empty());
        for (i, arg) in args.iter().enumerate() {
          arg.print_tree(&new_prefix, i == args.len() - 1);
        }
      },
      Expr::Path(path) => {
        println!("{}{} Path: {}", prefix, connector, format_path(path));
      },
      Expr::Block { stmts, .. } => {
        println!("{}{} Block", prefix, connector);
        let new_prefix = format!("{}{}  ", prefix, if is_last { " " } else { "│" });
        for (i, stmt) in stmts.iter().enumerate() {
          stmt.print_tree(&new_prefix, i == stmts.len() - 1);
        }
      },
      Expr::Ident { name, .. } => {
        println!("{}{} Ident: '{}'", prefix, connector, name);
      },
      Expr::Field { object, field, .. } => {
        println!("{}{} Field", prefix, connector);
        let new_prefix = format!("{}{}  ", prefix, if is_last { " " } else { "│" });

        object.print_tree(&new_prefix, false);

        match field {
          FieldAccess::Named(name) => {
            println!("{}└── Named field: {}", new_prefix, name);
          },
          FieldAccess::Unnamed(index) => {
            println!("{}└── Unnamed field: .{}", new_prefix, index);
          },
        }
      },
      Expr::Index { object, index, .. } => {
        println!("{}{} Index", prefix, connector);
        let new_prefix = format!("{}{}  ", prefix, if is_last { " " } else { "│" });
        object.print_tree(&new_prefix, false);
        index.print_tree(&new_prefix, true);
      },
      Expr::Try { expr, .. } => {
        println!("{}{} Try", prefix, connector);
        let new_prefix = format!("{}{}  ", prefix, if is_last { " " } else { "│" });
        expr.print_tree(&new_prefix, true);
      },
      Expr::Await { expr, .. } => {
        println!("{}{} Await", prefix, connector);
        let new_prefix = format!("{}{}  ", prefix, if is_last { " " } else { "│" });
        expr.print_tree(&new_prefix, true);
      },

      Expr::Cast { expr, ty, .. } => {
        println!("{}{} Cast", prefix, connector);
        let new_prefix = format!("{}{}  ", prefix, if is_last { " " } else { "│" });
        println!("{}├─> Expr:", new_prefix);
        expr.print_tree(&format!("{}│  ", new_prefix), true);
        println!("{}└─> Type:", new_prefix);
        ty.print_tree(&format!("{}   ", new_prefix), true);
      },

      Expr::Array /*@_DONE_@*/ {
        elements, repeat, ..
      } => {
        println!("{}{} Array", prefix, connector);

        // Determine if we have children (elements block + optional repeat block)
        let has_elements = !elements.is_empty();
        let has_repeat = repeat.is_some();
        let child_count = (has_elements as usize) + (has_repeat as usize);

        // No children → empty array
        if child_count == 0 {
          let empty_connector = "└──";
          let empty_prefix = format!("{}    ", prefix);
          println!("{}{} <empty>", empty_prefix, empty_connector);
          return;
        }

        // Build the prefix for children
        let child_prefix = format!("{}{}   ", prefix, if is_last { " " } else { "│" });

        let mut child_index = 0;

        // --------------------- ELEMENTS BLOCK ---------------------
        if has_elements {
          let is_last_child = child_index + 1 == child_count;
          let elem_connector = if is_last_child {
            "└──"
          } else {
            "├──"
          };

          println!("{}{} Elements", child_prefix, elem_connector);

          // prefix for actual element expressions
          let elem_child_prefix = format!(
            "{}{}   ",
            child_prefix,
            if is_last_child { " " } else { "│" }
          );

          for (i, expr) in elements.iter().enumerate() {
            let last_expr = i + 1 == elements.len();
            let connector = if last_expr { "└──" } else { "├──" };

            expr.print_tree(&elem_child_prefix, last_expr);
          }

          child_index += 1;
        }

        // --------------------- REPEAT BLOCK -----------------------
        if let Some(repeat_expr) = repeat {
          let is_last_child = child_index + 1 == child_count;
          let rep_connector = if is_last_child {
            "└──"
          } else {
            "├──"
          };

          println!("{}{} Repeat", child_prefix, rep_connector);

          let rep_child_prefix = format!(
            "{}{}   ",
            child_prefix,
            if is_last_child { " " } else { "│" }
          );

          repeat_expr.print_tree(&rep_child_prefix, true);
        }
      },

      Expr::Range {
        start, end, kind, ..
      } => {
        println!("{}{} Range", prefix, connector);
        let range_prefix = format!("{}{}  ", prefix, if is_last { " " } else { "│" });

        let has_start = start.is_some();
        let has_end = end.is_some();

        // Determine if "RangeKind" is the only child
        let last_is_kind = !has_start && !has_end;

        // --- Start ---
        if let Some(expr) = start {
          let start_connector = if !has_end { "├─>" } else { "├─>" }; // start always first
          println!("{}{} Start:", range_prefix, start_connector);

          // continue bar only if end exists
          let start_prefix = format!("{}{}  ", range_prefix, if has_end { "│" } else { " " });
          expr.print_tree(&start_prefix, !has_end && !last_is_kind);
        } else {
          println!("{}├─> Start: <none>", range_prefix);
        }

        // --- End ---
        if let Some(expr) = end {
          // end is last before RangeKind
          println!("{}├─> End:", range_prefix);
          let end_prefix = format!("{}│  ", range_prefix);
          expr.print_tree(&end_prefix, false);
        } else {
          println!("{}├─> End: <none>", range_prefix);
        }

        // --- RangeKind (always last) ---
        println!("{}└─> RangeKind: {:?}", range_prefix, kind);
      },

      Expr::Struct {
        path, fields, base, ..
      } => {
        println!("{}{} Struct", prefix, connector);
        let struct_prefix = format!("{}{}  ", prefix, if is_last { " " } else { "│" });

        // Path
        println!("{}├─> Path: {}", struct_prefix, format_path(path));

        // Fields
        if fields.is_empty() {
          println!("{}├─> Fields: <empty>", struct_prefix);
        } else {
          println!("{}├─> Fields:", struct_prefix);

          // The "Fields:" node itself has a sibling ("Base:") because you always print Base,
          // so the carrier under "Fields:" must be a vertical bar.
          let fields_carrier = format!("{}│  ", struct_prefix);

          for (i, field) in fields.iter().enumerate() {
            let is_last_field = i + 1 == fields.len();

            // Header for the field
            let field_connector = if is_last_field { "└─>" } else { "├─>" };
            println!(
              "{}{} Field: {}",
              fields_carrier, field_connector, field.name
            );

            // For children under this field, keep the Fields carrier,
            // but stop the field-level bar if this is the last field.
            let field_children_prefix = format!(
              "{}{}  ",
              fields_carrier,
              if is_last_field { " " } else { "│" }
            );

            // Attributes block (if any)
            if !field.attributes.is_empty() {
              // If there is also a value, attributes are not last; otherwise they are last.
              let attrs_last = field.value.is_none();
              let attrs_conn = if attrs_last { "└─>" } else { "├─>" };
              println!("{}{} Attributes:", field_children_prefix, attrs_conn);

              let attrs_carrier = format!(
                "{}{}  ",
                field_children_prefix,
                if attrs_last { " " } else { "│" }
              );

              for (j, attr) in field.attributes.iter().enumerate() {
                let last_attr = j + 1 == field.attributes.len();
                let attr_branch = if last_attr { "└─>" } else { "├─>" };
                println!("{}{} {}", attrs_carrier, attr_branch, format_attr(attr));
              }
            }

            // Value block
            println!("{}└─> Value:", field_children_prefix);
            if let Some(ref value) = field.value {
              let val_prefix = format!("{}   ", field_children_prefix);
              value.print_tree(&val_prefix, true);
            } else {
              println!("{}   └─> <none>", field_children_prefix);
            }
          }
        }

        // Base (always printed)
        println!("{}└─> Base:", struct_prefix);
        if let Some(base_expr) = base {
          base_expr.print_tree(&format!("{}   ", struct_prefix), true);
        } else {
          println!("{}   └─> <none>", struct_prefix);
        }
      },

      Expr::Unit(_) => {
        println!("{}{}  Unit:()", prefix, connector);
      },

      _ => {
        println!("{}{} [Other Expr]", prefix, connector);
      },
    }
  }
}

/// Format a unified Path into a string representation
pub(crate) fn format_path(p: &Path) -> String {
  let mut s = String::new();
  if p.leading_colon {
    s.push_str("::");
  }

  for (i, seg) in p.segments.iter().enumerate() {
    if i > 0 {
      s.push_str("::");
    }

    // Print segment name
    match &seg.kind {
      PathSegmentKind::Ident(id) => s.push_str(id),
      PathSegmentKind::Super => s.push_str("super"),
      PathSegmentKind::Self_ => s.push_str("self"),
      PathSegmentKind::Crate => s.push_str("crate"),
      PathSegmentKind::DollarCrate => s.push_str("$crate"),
      PathSegmentKind::SelfType => s.push_str("Self"),
    }

    // Print any generic arguments
    if let Some(args) = &seg.args {
      s.push_str(&format_generic_args(args));
    }
  }

  s
}

pub(crate) fn format_generic_args(args: &GenericArgs) -> String {
  match args {
    GenericArgs::AngleBracketed { args } => {
      let inner = args
        .iter()
        .map(format_generic_arg)
        .collect::<Vec<_>>()
        .join(", ");
      format!("<{}>", inner)
    },
    GenericArgs::Parenthesized { inputs, output } => {
      let ins = inputs
        .iter()
        .map(format_type)
        .collect::<Vec<_>>()
        .join(", ");
      match output {
        Some(out) => format!("({}) -> {}", ins, format_type(out)),
        None => format!("({})", ins),
      }
    },
  }
}

pub(crate) fn format_generic_arg(arg: &GenericArg) -> String {
  match arg {
    GenericArg::Lifetime(name) => format!("'{}", name),
    GenericArg::Type(ty) => format_type(ty),
    GenericArg::Const(expr) => format_expr(expr),
    GenericArg::Binding { name, ty, .. } => format!("{} = {}", name, format_type(ty)),
    GenericArg::Constraint { name, bounds, .. } => {
      let b = bounds
        .iter()
        .map(format_type_bound)
        .collect::<Vec<_>>()
        .join(" + ");
      format!("{}: {}", name, b)
    },
  }
}

pub(crate) fn format_type(ty: &Type) -> String {
  match ty {
    Type::Path(p) => format_path(p),
    Type::Tuple(types) => {
      let t = types.iter().map(format_type).collect::<Vec<_>>().join(", ");
      format!("({})", t)
    },
    Type::Reference {
      inner, mutability, ..
    } => {
      let m = match mutability {
        Mutability::Mutable => "mut ",
        Mutability::Immutable => "",
      };
      format!("&{}{}", m, format_type(inner))
    },
    Type::Array { element, size } => format!("[{}; {}]", format_type(element), format_expr(size)),
    Type::Slice(inner) => format!("[{}]", format_type(inner)),
    Type::BareFn {
      params,
      return_type,
      ..
    } => {
      let ps = params
        .iter()
        .map(|p| format_type(&p.ty))
        .collect::<Vec<_>>()
        .join(", ");
      match return_type {
        Some(ret) => format!("fn({}) -> {}", ps, format_type(ret)),
        None => format!("fn({})", ps),
      }
    },
    Type::Infer => "_".into(),
    _ => format!("{:?}", ty),
  }
}

fn format_type_bound(bound: &TypeBound) -> String {
  let prefix = match bound.modifier {
    TraitBoundModifier::Maybe => "?",
    TraitBoundModifier::MaybeConst => "?const ",
    TraitBoundModifier::Const => "const ",
    TraitBoundModifier::None => "",
  };
  let path = format_path(&bound.path);
  format!("{prefix}{path}")
}

pub(crate) fn format_expr(expr: &Expr) -> String {
  match expr {
    Expr::Ident { name, .. } => name.clone(),
    Expr::Integer { value, suffix, .. } => {
      if let Some(suf) = suffix {
        format!("{}{}", value, suf)
      } else {
        value.to_string()
      }
    },
    Expr::String { value, .. } => value.clone(),
    _ => "[expr]".into(),
  }
}

fn format_tt(tt: &TokenTree) -> String {
  match tt {
    TokenTree::Token(t) => t.clone(),
    TokenTree::Delimited { delimiter, tokens } => {
      let (l, r) = match delimiter {
        Delimiter::Paren => ('(', ')'),
        Delimiter::Bracket => ('[', ']'),
        Delimiter::Brace => ('{', '}'),
      };
      let inner = tokens.iter().map(format_tt).collect::<Vec<_>>().join(" ");
      format!("{l}{inner}{r}")
    },
    TokenTree::Repeat { .. } => "$( … )*".into(),
    TokenTree::MetaVar { name, kind } => format!("${name}:{kind}"),
  }
}

pub(crate) fn format_attr(attr: &Attribute) -> String {
  match &attr.kind {
    AttrKind::Normal { path, tokens } => {
      let prefix = match attr.style {
        AttrStyle::Inner => "#!",
        AttrStyle::Outer => "#",
      };
      let p = format_path(path);
      if tokens.is_empty() {
        format!("{prefix}[{p}]")
      } else if tokens.len() == 1 {
        // Common case: a single delimited token tree like (feature="debug")
        let t = format_tt(&tokens[0]);
        format!("{prefix}[{p}{t}]")
      } else {
        // Fallback: join multiple token trees with spaces
        let joined = tokens.iter().map(format_tt).collect::<Vec<_>>().join(" ");
        format!("{prefix}[{p} {joined}]")
      }
    },
    AttrKind::DocComment { is_inner, content } => {
      if *is_inner {
        format!("//! {content}")
      } else {
        format!("/// {content}")
      }
    },
    AttrKind::Cfg(meta) => {
      let prefix = match attr.style {
        AttrStyle::Inner => "#!",
        AttrStyle::Outer => "#",
      };
      format!("{prefix}[cfg({meta:?})]")
    },
    AttrKind::CfgAttr { condition, attrs } => {
      let prefix = match attr.style {
        AttrStyle::Inner => "#!",
        AttrStyle::Outer => "#",
      };
      let inner = attrs.len();
      format!("{prefix}[cfg_attr({condition:?}, /* {inner} attr(s) */)]")
    },
  }
}
