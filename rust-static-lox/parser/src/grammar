/*
 * Complete Rust Grammar - Recursive Descent Parsing Style (ASCII only)
 * Models rustc behavior modulo macro expansion and semantic checks.
 */

program           -> shebang? innerAttr* item* EOF ;

shebang           -> "#!" ~[\n]* ;

/* ------------------------------------------------------------------------- */
/* Items                                                                     */
/* ------------------------------------------------------------------------- */

item              -> outerAttr* visItem ;

visItem           -> visibility? itemKind
                   | macroItem ;

itemKind          -> functionItem
                   | structItem
                   | enumItem
                   | traitItem
                   | implItem
                   | constItem
                   | staticItem
                   | typeAliasItem
                   | moduleItem
                   | useItem
                   | externCrateItem
                   | foreignModItem
                   | unionItem
                   | externTypeItem ;

/* ------------------------------------------------------------------------- */
/* Macros                                                                    */
/* ------------------------------------------------------------------------- */

macroItem         -> macroInvocationSemi
                   | macroRulesItem
                   | macro2Item ;

outerAttr         -> "#" "[" attrInput "]" ;
innerAttr         -> "#" "!" "[" attrInput "]" ;

attrInput         -> simplePath attrInputTail? ;

attrInputTail     -> delimTokenTree
                   | "=" expression ;

delimTokenTree    -> "(" tokenStream ")"
                   | "[" tokenStream "]"
                   | "{" tokenStream "}" ;

metaItem          -> simplePath ("(" metaSeq ")" | "=" literalExpr)? ;
metaSeq           -> metaItemInner ("," metaItemInner)* ","? ;
metaItemInner     -> metaItem | literalExpr ;

/* ------------------------------------------------------------------------- */
/* Functions                                                                 */
/* ------------------------------------------------------------------------- */

/* Split signature from bodies to model semantics precisely */
functionSig       -> functionQualifiers "fn" IDENTIFIER
                     genericParams? "(" functionParams? ")" functionReturnType?
                     whereClause? ;

functionItem      -> functionSig blockExpr ;                 /* free functions need a body */

foreignFunctionItem
                  -> functionSig ";" ;                       /* foreign items end with ';' */

associatedFunctionItem
                  -> functionSig (blockExpr | ";") ;         /* traits may have default bodies or ';' */

/* Qualifiers */
functionQualifiers -> "const"? "async"? "unsafe"? ("extern" abi?)? ;

abi               -> STRING | RAW_STRING ;

functionParams    -> selfParam ("," functionParam)* ","?
                   | functionParam ("," functionParam)* ","? ;

selfParam         -> outerAttr* (shorthandSelf | typedSelf) ;
shorthandSelf     -> ("&" LIFETIME?)? "mut"? "self" ;
typedSelf         -> "mut"? "self" ":" type ;

functionParam     -> outerAttr* (functionParamPattern | "...") ;
functionParamPattern -> patternNoTopAlt (":" (type | "..."))? ;

functionReturnType -> "->" type ;

/* ------------------------------------------------------------------------- */
/* Structs                                                                   */
/* ------------------------------------------------------------------------- */

/*
   Struct where placement rules:
   - record:    where BEFORE '{', no trailing ';'
   - tuple:     where AFTER ')', then ';' is required
   - unit:      where BEFORE ';', ';' is required
*/
structItem        -> "struct" IDENTIFIER genericParams?
                     ( whereClause? recordStructFields
                     | tupleStructFields whereClause? ";"
                     | whereClause? ";"
                     ) ;

recordStructFields -> "{" structFields? "}" ;
structFields      -> structField ("," structField)* ","? ;
structField       -> outerAttr* visibility? IDENTIFIER ":" type ;

tupleStructFields -> "(" tupleFields? ")" ;
tupleFields       -> tupleField ("," tupleField)* ","? ;
tupleField        -> outerAttr* visibility? type ;

/* ------------------------------------------------------------------------- */
/* Enums                                                                     */
/* ------------------------------------------------------------------------- */

enumItem          -> "enum" IDENTIFIER genericParams?
                     whereClause? "{" enumVariants? "}" ;

enumVariants      -> enumVariant ("," enumVariant)* ","? ;

enumVariant       -> outerAttr* visibility? IDENTIFIER
                     (enumVariantFields | discriminant)? ;

enumVariantFields -> recordStructFields | tupleStructFields ;
discriminant      -> "=" expression ;

/* ------------------------------------------------------------------------- */
/* Union                                                                     */
/* ------------------------------------------------------------------------- */

unionItem         -> "union" IDENTIFIER genericParams?
                     whereClause? recordStructFields ;

/* ------------------------------------------------------------------------- */
/* Consts, Statics, Type Aliases                                              */
/* ------------------------------------------------------------------------- */

/* Free-standing const must have initializer */
constItem         -> "const" (IDENTIFIER | "_") ":" type "=" expression ";" ;

/* Free-standing static may omit initializer */
staticItem        -> "static" "mut"? IDENTIFIER ":" type
                     ("=" expression)? ";" ;

/* Free-standing type alias must have '=' type */
typeAliasItem     -> "type" IDENTIFIER genericParams?
                     (":" typeParamBounds)?
                     whereClause? "=" type ";" ;

/* ------------------------------------------------------------------------- */
/* Traits and Impl                                                            */
/* ------------------------------------------------------------------------- */

traitItem         -> "unsafe"? "auto"? "trait" IDENTIFIER
                     genericParams? (":" typeParamBounds)?
                     whereClause? "{" innerAttr* associatedItem* "}" ;

implItem          -> "unsafe"? "impl" genericParams?
                     "const"? "!"? traitPath "for" type
                     whereClause? "{" innerAttr* associatedItem* "}"
                   | "unsafe"? "impl" genericParams? type
                     whereClause? "{" innerAttr* inherentImplItem* "}" ;

traitPath         -> typePath ;

associatedItem    -> outerAttr* (macroInvocationSemi | associatedItemKind) ;

associatedItemKind -> associatedTypeItem
                    | associatedConstItem
                    | associatedFunctionItem ;

/* Associated type: generics (GATs) allowed, optional bounds, optional where, optional default */
associatedTypeItem -> "type" IDENTIFIER genericParams? (":" typeParamBounds)?
                      whereClause? ("=" type)? ";" ;

/* Associated const: in traits value is optional, in impls it must be provided (semantic rule) */
associatedConstItem -> "const" IDENTIFIER ":" type ("=" expression)? ";" ;

inherentImplItem  -> outerAttr* (visibility? (functionItem | constItem) | macroInvocationSemi) ;

/* ------------------------------------------------------------------------- */
/* Externs, Modules, Use                                                      */
/* ------------------------------------------------------------------------- */

externCrateItem   -> "extern" "crate" crateRef asClause? ";" ;
crateRef          -> IDENTIFIER | "self" ;
asClause          -> "as" (IDENTIFIER | "_") ;

useItem           -> "use" useTree ";" ;
useTree           -> (simplePath? "::")? ("*" | useTreeList)
                   | simplePath ("as" (IDENTIFIER | "_"))? ;
useTreeList       -> "{" (useTree ("," useTree)* ","?)? "}" ;

moduleItem        -> "mod" IDENTIFIER (";" | "{" innerAttr* item* "}") ;

/* Foreign module: only foreignFunctionItem and foreign statics inside */
foreignModItem    -> "unsafe"? "extern" abi? "{" innerAttr* externalItem* "}" ;
externalItem      -> outerAttr* (macroInvocationSemi | (visibility? externalItemKind)) ;
externalItemKind  -> "static" "mut"? IDENTIFIER ":" type ";"
                   | foreignFunctionItem ;

/* extern type is a separate free item (no generics) */
externTypeItem    -> "extern" "type" IDENTIFIER ";" ;

/* ------------------------------------------------------------------------- */
/* Macros (defs)                                                              */
/* ------------------------------------------------------------------------- */

macroRulesItem    -> "macro_rules" "!" IDENTIFIER macroRulesDef ;
macroRulesDef     -> "(" macroRules ")" ";"
                   | "{" macroRules "}"
                   | "[" macroRules "]" ;

macroRules        -> macroRule (";" macroRule)* ";"? ;
macroRule         -> macroMatcher "=>" macroTranscriber ;

macroMatcher      -> "(" macroMatch* ")"
                   | "[" macroMatch* "]"
                   | "{" macroMatch* "}" ;

macroMatch        -> tokenExceptDelims
                   | macroMatcher
                   | "$" (IDENTIFIER ":" macroFragSpec | "(" macroMatch+ ")" macroRepSep? macroRepOp) ;

macroFragSpec     -> "block" | "expr" | "ident" | "item" | "lifetime" | "literal"
                   | "meta" | "pat" | "pat_param" | "path" | "stmt" | "tt" | "ty" | "vis" ;

macroRepSep       -> tokenExceptDelims | macroRepOp ;
macroRepOp        -> "*" | "+" | "?" ;

macroTranscriber  -> delimTokenTree ;

macro2Item        -> "macro" IDENTIFIER "(" macroParams? ")" delimTokenTree ;
macroParams       -> IDENTIFIER ("," IDENTIFIER)* ","? ;

/* ------------------------------------------------------------------------- */
/* Generics                                                                   */
/* ------------------------------------------------------------------------- */

genericParams     -> "<" (genericParam ("," genericParam)* ","?)? ">" ;
genericParam      -> outerAttr* (lifetimeParam | typeParam | constParam) ;

lifetimeParam     -> LIFETIME (":" lifetimeBounds)? ;

/* type param: optional bounds, optional default */
typeParam         -> IDENTIFIER (":" typeParamBounds)? ("=" type)? ;

/* const param: allow const-evaluable defaults */
constParam        -> "const" IDENTIFIER ":" type ("=" block | "=" IDENTIFIER | "=" literalExpr)? ;

/* where clause */
whereClause       -> "where" (whereClauseItem ("," whereClauseItem)* ","?)? ;
whereClauseItem   -> lifetimeWhereClauseItem
                   | typeBoundWhereClauseItem ;

lifetimeWhereClauseItem -> LIFETIME ":" lifetimeBounds ;
typeBoundWhereClauseItem -> forLifetimes? type ":" typeParamBounds? ;

/* bounds */
lifetimeBounds    -> (LIFETIME ("+" LIFETIME)*)? "+"? ;
typeParamBounds   -> typeParamBound ("+" typeParamBound)* "+"? ;
typeParamBound    -> LIFETIME
                   | traitBound ;

/* trait bounds */
traitBound        -> "?"? "const"? forLifetimes? typePath ;

/* HRTB: only lifetimes may appear inside for<...> */
forLifetimes      -> "for" "<" LIFETIME ("," LIFETIME)* ","? ">" ;

/* generic args on paths: lifetimes, types, consts, bindings, and (contextually) constraints */
genericArgs       -> "<" genericArg ("," genericArg)* ","?
                   | "::" "<" genericArg ("," genericArg)* ","? ">" ;

genericArg        -> LIFETIME
                   | type
                   | genericArgsConst
                   | genericArgsBinding
                   | constrainedTypeParam ;

/* const args: grammar-level expression; evaluator enforces const-evaluable */
genericArgsConst  -> expression ;

/* equality binding: e.g., Item<'a> = T */
genericArgsBinding -> IDENTIFIER genericArgs? "=" type ;

/* constrained type param (allowed contextually in bounds, like Item: Trait) */
constrainedTypeParam -> IDENTIFIER genericArgs? ":" typeParamBounds ;

/* ------------------------------------------------------------------------- */
/* Visibility                                                                 */
/* ------------------------------------------------------------------------- */

visibility        -> "pub" ("(" ("crate" | "self" | "super" | "in" simplePath) ")")? ;

/* ------------------------------------------------------------------------- */
/* Types                                                                      */
/* ------------------------------------------------------------------------- */

type              -> typeNoBounds
                   | implTraitType
                   | traitObjectType ;

typeNoBounds      -> parenthesizedType
                   | implTraitTypeOneBound
                   | traitObjectTypeOneBound
                   | typePath
                   | tupleType
                   | neverType
                   | rawPointerType
                   | referenceType
                   | arrayType
                   | sliceType
                   | inferredType
                   | qualifiedPathInType
                   | bareFunctionType
                   | macroInvocation ;

parenthesizedType -> "(" type ")" ;

tupleType         -> "(" ")"
                   | "(" (type ",")+ type? ")" ;

neverType         -> "!" ;

rawPointerType    -> "*" ("mut" | "const") typeNoBounds ;
referenceType     -> "&" LIFETIME? "mut"? typeNoBounds ;

arrayType         -> "[" type ";" expression "]" ;
sliceType         -> "[" type "]" ;
inferredType      -> "_" ;

qualifiedPathInType -> qualifiedPathType ("::" typePath)? ;
qualifiedPathType  -> "<" type ("as" typePath)? ">" ;

/* Note: no turbofish '::<' in type paths */
typePath          -> "::"? typePathSegment ("::" typePathSegment)* ;
typePathSegment   -> pathIdentSegment genericArgs? ;

/* ------------------------------------------------------------------------- */
/* Paths in expressions                                                       */
/* ------------------------------------------------------------------------- */

simplePath        -> "::"? simplePathSegment ("::" simplePathSegment)* ;  [x]
simplePathSegment -> IDENTIFIER | "super" | "self" | "crate" | "$crate" ; [x]

pathInExpression  -> "::"? pathExprSegment ("::" pathExprSegment)* ;      [x]
pathExprSegment   -> pathIdentSegment ("::" genericArgs)? ;               [x]
pathIdentSegment  -> IDENTIFIER | "super" | "self" | "Self" | "crate" | "$crate" ; [x]

qualifiedPathInExpression -> qualifiedPathType ("::" pathExprSegment)+ ;  [x]

/* ------------------------------------------------------------------------- */
/* Patterns                                                                  */
/* ------------------------------------------------------------------------- */

pattern           -> "|"? patternNoTopAlt ("|" patternNoTopAlt)* ; [x]

patternNoTopAlt   -> patternWithoutRange [x]
                   | rangePattern ;      [x]

patternWithoutRange 
                  -> literalPattern         [x]
                   | identifierPattern      [x]
                   | wildcardPattern        [x]
                   | restPattern            [x]
                   | referencePattern       [x]
                   | structPattern          [x]
                   | tupleStructPattern     [x]
                   | tuplePattern           [x]
                   | groupedPattern         [x]
                   | slicePattern           [x]
                   | pathPattern            [x]
                   | macroInvocation ;      [x]

literalPattern    -> "true" | "false"      [x]
                   | CHAR                [x]
                   | BYTE                [x]
                   | STRING              [x]
                   | RAW_STRING          [x]
                   | BYTE_STRING         [x]
                   | RAW_BYTE_STRING     [x]
                   | C_STRING            [x]
                   | RAW_C_STRING        [x]
                   | INTEGER             [x]
                   | FLOAT               [x]
                   | "-" INTEGER         [x]
                   | "-" FLOAT ;         [x]

identifierPattern -> "ref"? "mut"? IDENTIFIER ("@" patternNoTopAlt)? ; [x]
wildcardPattern   -> "_" ; [x]
restPattern       -> ".." ; [x]
referencePattern  -> ("&" | "&&") "mut"? patternWithoutRange ; [x]

structPattern     -> pathInExpression "{" structPatternElements? "}" ; [x]
structPatternElements
                  -> structPatternFields ("," structPatternEtCetera?)? [x]
                   | structPatternEtCetera ; [x]
structPatternFields -> structPatternField ("," structPatternField)* ; [x]
structPatternField -> outerAttr* (tupleIndex ":" patternNoTopAlt [x]
                                  | IDENTIFIER ":" patternNoTopAlt [x]
                                  | "ref"? "mut"? IDENTIFIER) ; [x]
structPatternEtCetera -> outerAttr* ".." ; [x]

tupleStructPattern -> pathInExpression "(" tuplePatternItems? ")" ; [x]
tuplePattern      -> "(" tuplePatternItems? ")" ; [x]
tuplePatternItems -> pattern ("," pattern)* ","? [x]
                   | restPattern ("," pattern)+ ","? [x]
                   | pattern ("," pattern)* "," restPattern ("," pattern)* ","? ; [x]

groupedPattern    -> "(" pattern ")" ; [x]
slicePattern      -> "[" slicePatternItems? "]" ; [x]
slicePatternItems -> pattern ("," pattern)* ","? ; [x]

pathPattern       -> pathInExpression             [x]
                   | qualifiedPathInExpression ;  [x]

rangePattern      -> rangePatternBound ("..=" | "...") rangePatternBound [x]
                   | rangeInclusiveStart [x]
                   | obsoleteRangePattern ; [x]

rangePatternBound -> CHAR | BYTE | "-"? INTEGER | "-"? FLOAT | pathInExpression ; [x]
rangeInclusiveStart -> rangePatternBound "..=" ; [x]
obsoleteRangePattern -> rangePatternBound "..." ; [x]

/* ------------------------------------------------------------------------- */
/* Statements                                                                 */
/* ------------------------------------------------------------------------- */

statement         -> ";"
                   | item
                   | letStatement
                   | expressionStatement
                   | macroInvocationSemi ;

letStatement      -> outerAttr* "let" patternNoTopAlt (":" type)? ("=" expression ("else" blockExpr)?)? ";" ;
expressionStatement -> expressionWithoutBlock ";"
                     | expressionWithBlock ";"? ;

/* ------------------------------------------------------------------------- */
/* Macro invocations in expr/stmt                                             */
/* ------------------------------------------------------------------------- */

macroInvocationSemi -> simplePath "!" delimTokenTree ";" ;

/* ------------------------------------------------------------------------- */
/* Expressions                                                                */
/* ------------------------------------------------------------------------- */

expression        -> assignment ;
assignment        -> (rangeExpr assignOp)* rangeExpr ;
assignOp          -> "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" ;

rangeExpr         -> logicalOr (rangeOp logicalOr)? ;
rangeOp           -> ".." | "..=" ;

logicalOr         -> logicalAnd ("||" logicalAnd)* ;
logicalAnd        -> comparison ("&&" comparison)* ;

comparison        -> bitwiseOr (comparisonOp bitwiseOr)* ;
comparisonOp      -> "==" | "!=" | "<" | "<=" | ">" | ">=" ;

bitwiseOr         -> bitwiseXor ("|" bitwiseXor)* ;
bitwiseXor        -> bitwiseAnd ("^" bitwiseAnd)* ;
bitwiseAnd        -> shift ("&" shift)* ;

shift             -> term (shiftOp term)* ;
shiftOp           -> "<<" | ">>" ;

term              -> factor (termOp factor)* ;
termOp            -> "+" | "-" ;

factor            -> cast (factorOp cast)* ;
factorOp          -> "*" | "/" | "%" ;

cast              -> unary ("as" typeNoBounds)* ;

unary             -> unaryOp* postfix ;
unaryOp           -> "-" | "!" | "*" | "&" "mut"? | "&&" "mut"? ;

postfix           -> primary postfixOp* ;
postfixOp         -> callOp
                   | methodCallOp
                   | fieldAccessOp
                   | tupleIndexOp
                   | indexOp
                   | awaitOp
                   | tryOp ;

callOp            -> "(" callParams? ")" ;
methodCallOp      -> "." pathExprSegment "(" callParams? ")" ;
fieldAccessOp     -> "." IDENTIFIER ;
tupleIndexOp      -> "." INTEGER ;
indexOp           -> "[" expression "]" ;
awaitOp           -> "." "await" ;
tryOp             -> "?" ;

callParams        -> expression ("," expression)* ","? ;

primary           -> literalExpr       [x]
                   | pathExpr          [x]
                   | groupedExpr       [x]
                   | arrayExpr         [x]
                   | tupleExpr         [x]
                   | structExpr 
                   | closureExpr       [x]
                   | blockExpr         [x]
                   | asyncBlockExpr    [x]
                   | unsafeBlockExpr   [x]
                   | tryBlockExpr      [x]
                   | loopExpr          [-]
                   | ifExpr            [x]
                   | ifLetExpr         [x]
                   | matchExpr         [x]
                   | continueExpr      [x]
                   | breakExpr         [x]
                   | returnExpr        [x]
                   | macroInvocation ; [x]

literalExpr       -> CHAR            [x]
                   | STRING          [x]
                   | RAW_STRING      [x]
                   | BYTE            [x]
                   | BYTE_STRING     [x]
                   | RAW_BYTE_STRING [x]
                   | C_STRING        [x]
                   | RAW_C_STRING    [x]
                   | INTEGER         [x]
                   | FLOAT           [x]
                   | "true"          [x]
                   | "false" ;       [x]

pathExpr          -> pathInExpression
                   | qualifiedPathInExpression ; [-]

groupedExpr       -> "(" expression ")" ; [x]

arrayExpr         -> "[" arrayElements? "]" ;                               [x]     
arrayElements     -> expression (";" expression | ("," expression)* ","?) ; [x]

tupleExpr         -> "(" tupleElements? ")" ;        [x]
tupleElements     -> (expression ",")+ expression? ; [x]

structExpr        -> structExprStruct
                   | structExprTuple
                   | structExprUnit ;

structExprStruct  -> pathInExpression "{" (structExprFields | structBase)? "}" ;
structExprFields  -> structExprField ("," structExprField)* ("," structBase | ","?) ;
structExprField   -> outerAttr* (IDENTIFIER | (IDENTIFIER | tupleIndex) ":" expression) ;
structBase        -> ".." expression ;

structExprTuple   -> pathInExpression "(" (expression ("," expression)* ","?)? ")" ;
structExprUnit    -> pathInExpression ;

closureExpr       -> "move"? "async"? ("||" | "|" closureParams? "|") (expression | "->" typeNoBounds blockExpr) ; [x]
closureParams     -> closureParam ("," closureParam)* ","? ;                                                       [x]
closureParam      -> outerAttr* patternNoTopAlt (":" type)? ;                                                      [x]

blockExpr         -> outerAttr* "{" innerAttr* statements? "}" ;   [x]
unsafeBlockExpr   -> outerAttr* "unsafe" blockExpr ;               [x]
asyncBlockExpr    -> outerAttr* "async" "move"? blockExpr ;        [x]
tryBlockExpr      -> outerAttr* "try" blockExpr ; // nightly only  [x]

statements        -> statement+ expression?
                   | expression ;

loopExpr          -> infiniteLoopExpr                                         [x]
                   | predicateLoopExpr                                        [x]
                   | predicatePatternLoopExpr                                 [x]
                   | iteratorLoopExpr                                         [x]
                   | labelBlockExpr ;                                         [x]

infiniteLoopExpr  -> loopLabel? "loop" blockExpr ;                                      [x]
predicateLoopExpr -> loopLabel? "while" expression blockExpr ;                          [x]
predicatePatternLoopExpr -> loopLabel? "while" "let" pattern "=" scrutinee blockExpr ;  [x]
iteratorLoopExpr  -> loopLabel? "for" pattern "in" expression blockExpr ;               [x]
loopLabel         -> LIFETIME ":" ;  [x]
labelBlockExpr    -> loopLabel blockExpr ; [x]

scrutinee         -> expression ; [x]

ifExpr            -> "if" expression blockExpr ("else" (blockExpr | ifExpr | ifLetExpr))? ;                  [x]
ifLetExpr         -> "if" "let" pattern "=" scrutinee blockExpr ("else" (blockExpr | ifExpr | ifLetExpr))? ; [x]

/* ------------------------------------------------------------------------- */
/* Match expressions (with inner + outer attributes)                         */
/* ------------------------------------------------------------------------- */

matchExpr         -> "match" scrutinee "{" matchArms? "}" ; [x]
matchArms         -> matchArm "=>" matchArmBody ","?    [x]
                   (matchArm "=>" matchArmBody ","?)* ; [x]
                   (matchArm "=>" matchArmBody ","?)* ; [x]
matchArmBody      -> expressionWithBlock                [x]
                   | expressionWithoutBlock ;           [x]
matchArm          -> outerAttr* pattern matchArmGuard? ; [x]
matchArmGuard     -> "if" expression ;                  [x]

continueExpr      -> "continue" LIFETIME? ; [x]
breakExpr         -> "break" LIFETIME? expression? ; [x]
returnExpr        -> "return" expression? ; [x]

/* ------------------------------------------------------------------------- */
/* ExpressionWithoutBlock / ExpressionWithBlock                              */
/* (mirroring the main expression grammar but restricting block forms)       */
/* ------------------------------------------------------------------------- */

/* Without-block expressions reuse the same precedence structure as `expression`,
 * but are built on a restricted `primaryWithoutBlock` that excludes
 * plain blocks, unsafe blocks, loops, if/if let, and match. Async blocks
 * (`asyncBlockExpr`) are included here.
 */

expressionWithoutBlock
                  -> outerAttr* assignmentWithoutBlock ;

assignmentWithoutBlock
                  -> (rangeExprWithoutBlock assignOp)* rangeExprWithoutBlock ;

rangeExprWithoutBlock
                  -> logicalOrWithoutBlock (rangeOp logicalOrWithoutBlock?)? ;

logicalOrWithoutBlock
                  -> logicalAndWithoutBlock ("||" logicalAndWithoutBlock)* ;

logicalAndWithoutBlock
                  -> comparisonWithoutBlock ("&&" comparisonWithoutBlock)* ;

comparisonWithoutBlock
                  -> bitwiseOrWithoutBlock (comparisonOp bitwiseOrWithoutBlock)* ;

bitwiseOrWithoutBlock
                  -> bitwiseXorWithoutBlock ("^" bitwiseXorWithoutBlock)* ;

bitwiseXorWithoutBlock
                  -> bitwiseAndWithoutBlock ("&" bitwiseAndWithoutBlock)* ;

bitwiseAndWithoutBlock
                  -> shiftWithoutBlock ("&" shiftWithoutBlock)* ;

shiftWithoutBlock -> termWithoutBlock (shiftOp termWithoutBlock)* ;
termWithoutBlock  -> factorWithoutBlock (termOp factorWithoutBlock)* ;

factorWithoutBlock
                  -> castWithoutBlock (factorOp castWithoutBlock)* ;

castWithoutBlock  -> unaryWithoutBlock ("as" typeNoBounds)* ;

unaryWithoutBlock -> unaryOp* postfixWithoutBlock ;

postfixWithoutBlock
                  -> primaryWithoutBlock postfixOp* ;

primaryWithoutBlock
                  -> literalExpr
                   | pathExpr
                   | groupedExpr
                   | arrayExpr
                   | tupleExpr
                   | structExpr
                   | closureExpr
                   | asyncBlockExpr
                   | continueExpr
                   | breakExpr
                   | returnExpr
                   | macroInvocation ;

/* With-block expressions at the outermost level */

expressionWithBlock
                  -> outerAttr* expressionKindWithBlock ;

expressionKindWithBlock
                  -> blockExpr
                   | unsafeBlockExpr
                   | tryBlockExpr
                   | loopExpr
                   | ifExpr
                   | ifLetExpr
                   | matchExpr ;

/* ------------------------------------------------------------------------- */
/* Macro invocation (expr/stmt/type)                                         */
/* ------------------------------------------------------------------------- */

macroInvocation   -> simplePath "!" delimTokenTree ;

/* ------------------------------------------------------------------------- */
/* Tokens                                                                     */
/* ------------------------------------------------------------------------- */

tokenStream       -> tokenTree* ;
tokenTree         -> tokenExceptDelims
                   | delimTokenTree ;

tupleIndex        -> INTEGER ;

/* ------------------------------------------------------------------------- */
/* Notes (semantic / disambiguation rules beyond pure CFG)                    */
/* - associatedConstItem: '=' is required in impls, optional in traits.       */
/* - structExpr vs blockExpr are disambiguated by looking ahead after the     */
/*   path: if it can start a struct literal, parse structExpr; otherwise      */
/*   parse blockExpr.                                                         */
/* - turbofish '::<' is only allowed in expression position; type paths       */
/*   do not use it.                                                           */
/* - genericArgs with constrainedTypeParam are only accepted in bound         */
/*   contexts (e.g., impl Trait / dyn Trait), not arbitrary type paths.       */
/* - const generic arguments must be const-evaluable; grammar accepts         */
/*   'expression' but the evaluator/enforcer restricts it.                    */
/* - macroInvocation, macroRules, and fragment kinds are additionally         */
/*   constrained by macro expansion context and fragment spec.                */
/* ------------------------------------------------------------------------- */

